// ----------------------------------------------------------
// Ghost Drone Sounder (invisible helper that plays the loop)
// ----------------------------------------------------------
class PM_GhostDroneSounder : Actor
{
    Default
    {
        +NOSECTOR;
        +NOBLOCKMAP;
        +NOINTERACTION;
        +NOGRAVITY;
        +NOCLIP;
    }

    void StartDrone(double vol)
    {
        A_StartSound("PM/GhostDroneLoop", CHAN_7, CHANF_LOOP, vol, ATTN_NONE);
    }

    void StopDrone()
    {
        A_StopSound(CHAN_7);
    }
}


// ----------------------------------------------------------
// Dimensional Stability Handler (summary moved to map start)
// ----------------------------------------------------------
class PM_DimensionalStabilityHandler : StaticEventHandler
{
    // --- Per-map state ---
    double dsLevelP;        // per-level random proportion (progression mode)
    bool   dsRolledThisMap; // has dsLevelP been rolled for this map?
    int    dsEligible;      // eligible monsters seen this map
    int    dsReplaced;      // replacements done this map

    // --- Ghost drone state ---
    PM_GhostDroneSounder ghostSounder;
    double ghostCurrentVolume;

    // --- Map-change tracking (prevents death-reload bumps) ---
    string lastMapName;

    // --- Deferred summary (printed at start of next map) ---
    string prevMapName;
    int    prevEligible;
    int    prevReplaced;

    // ---------------- Helpers ----------------
    bool DS_DebugEnabled()
    {
        CVar dbg = CVar.FindCVar("projectmalice_dimensionalstability_debug");
        return (dbg != null) && dbg.GetBool();
    }

    bool DroneEnabled()
    {
        CVar on = CVar.FindCVar("projectmalice_ghostdrone");
        return (on != null) && on.GetBool();
    }

    bool DroneDebug()
    {
        CVar on = CVar.FindCVar("projectmalice_ghostdrone_debug");
        return (on != null) && on.GetBool();
    }

    bool DS_IsEligible(Name c)
    {
        return  c == 'DoomImp'
             || c == 'Demon'
             || c == 'Spectre'
             || c == 'LostSoul'
             || c == 'Cacodemon'
             || c == 'Hellknight' || c == 'HellKnight'
             || c == 'BaronOfHell'
             || c == 'Revenant'
             || c == 'Arachnotron'
             || c == 'Fatso'
             || c == 'PainElemental'
             || c == 'Archvile';
    }

    double DS_GetActiveP()
    {
        double p = 0.0;
        CVar mode = CVar.FindCVar("projectmalice_dimensionalstability_mode");
        if (mode != null && mode.GetInt() == 1)
        {
            if (!dsRolledThisMap)
            {
                CVar prog = CVar.FindCVar("projectmalice_dimensionalstability_progression");
                double ceiling = (prog != null) ? prog.GetFloat() : 0.0;
                dsLevelP        = (ceiling > 0.0) ? frandom(0.0, ceiling) : 0.0;
                dsRolledThisMap = true;

                if (DS_DebugEnabled())
                    Console.Printf("[DS] Rolled per-level proportion: %d%%", int(dsLevelP * 100.0 + 0.5));
            }
            p = dsLevelP;
        }
        else
        {
            CVar stat = CVar.FindCVar("projectmalice_dimensionalstability");
            if (stat != null) p = stat.GetFloat();
        }

        if (p < 0.0) p = 0.0;
        if (p > 1.0) p = 1.0;
        return p;
    }

    void DS_UpdateDrone(double p)
    {
        if (!DroneEnabled())
        {
            if (ghostSounder)
            {
                ghostSounder.StopDrone();
                ghostSounder.Destroy();
                ghostSounder = null;
                ghostCurrentVolume = 0.0;
                if (DroneDebug()) Console.Printf("[DS:Drone] Disabled: stopping loop.");
            }
            return;
        }

        double vol;
        if (p <= 0.2) vol = 0.0;
        else          vol = (p - 0.2) / 0.8;
        if (vol < 0.0) vol = 0.0;
        if (vol > 1.0) vol = 1.0;

        if (!ghostSounder)
        {
            if (vol <= 0.0) return;
            ghostSounder = PM_GhostDroneSounder(Actor.Spawn("PM_GhostDroneSounder", (0,0,0)));
            if (ghostSounder)
            {
                ghostSounder.StartDrone(vol);
                ghostCurrentVolume = vol;
                if (DroneDebug()) Console.Printf("[DS:Drone] Start loop @ %.2f (p=%.2f).", vol, p);
            }
            return;
        }

        double diff = vol - ghostCurrentVolume; if (diff < 0) diff = -diff;
        if (vol <= 0.0)
        {
            ghostSounder.StopDrone();
            ghostSounder.Destroy();
            ghostSounder = null;
            ghostCurrentVolume = 0.0;
            if (DroneDebug()) Console.Printf("[DS:Drone] p=%.2f -> stopping loop.", p);
        }
        else if (diff > 0.01)
        {
            ghostSounder.StopDrone();
            ghostSounder.StartDrone(vol);
            ghostCurrentVolume = vol;
            if (DroneDebug()) Console.Printf("[DS:Drone] Update volume -> %.2f (p=%.2f).", vol, p);
        }
    }

    // ---------------- Lifecycle overrides ----------------

    override void NewGame()
    {
        // Reset progression and per-level state
        CVar prog = CVar.FindCVar("projectmalice_dimensionalstability_progression");
        if (prog != null) prog.SetFloat(0.0);

        dsLevelP        = -1.0;
        dsRolledThisMap = false;
        dsEligible      = 0;
        dsReplaced      = 0;

        // Drone state
        if (ghostSounder)
        {
            ghostSounder.StopDrone();
            ghostSounder.Destroy();
            ghostSounder = null;
        }
        ghostCurrentVolume = 0.0;

        // Map tracking
        lastMapName  = "";
        prevMapName  = "";
        prevEligible = 0;
        prevReplaced = 0;

        if (DS_DebugEnabled())
            Console.Printf("[DS] New Game: progression reset to 0%%");
    }

    // Increment on REAL map changes; print the previous level's summary here.
    override void WorldLoaded(WorldEvent e)
    {
        if (gamestate == GS_TITLELEVEL || deathmatch) return;

        // --- Print deferred summary for the level that just ended ---
        if (DS_DebugEnabled() && prevMapName != "")
        {
            Console.Printf("[DS] Level summary (%s): eligible=%d, replaced=%d",
                prevMapName, prevEligible, prevReplaced);
            // Clear once printed
            prevMapName  = "";
            prevEligible = 0;
            prevReplaced = 0;
        }

        bool haveLast   = (lastMapName != "");
        bool mapChanged = haveLast && (level.MapName != lastMapName);

        // Bump progression only when the map actually changes
        CVar mode = CVar.FindCVar("projectmalice_dimensionalstability_mode");
        if (mode != null && mode.GetInt() == 1 && mapChanged)
        {
            CVar prog = CVar.FindCVar("projectmalice_dimensionalstability_progression");
            CVar inc  = CVar.FindCVar("projectmalice_dimensionalstability_increment");
            if (prog != null && inc != null)
            {
                double newVal = prog.GetFloat() + inc.GetFloat();
                if (newVal > 1.0) newVal = 1.0;
                prog.SetFloat(newVal);

                if (DS_DebugEnabled())
                {
                    Console.Printf("[DS] Map change %s -> %s: +%d%% -> %d%% (cap 100%%)",
                        lastMapName, level.MapName,
                        int(inc.GetFloat() * 100.0 + 0.5),
                        int(newVal * 100.0 + 0.5));
                }
            }
        }

        // Reset per-map state on actual map change (or first playable map)
        if (!haveLast || mapChanged)
        {
            dsLevelP        = -1.0;
            dsRolledThisMap = false;
            dsEligible      = 0;
            dsReplaced      = 0;

            // Ensure the drone starts fresh on a new map
            if (ghostSounder)
            {
                ghostSounder.StopDrone();
                ghostSounder.Destroy();
                ghostSounder = null;
            }
            ghostCurrentVolume = 0.0;
        }

        // Update last seen map
        lastMapName = level.MapName;

        // Info-only prints for current map
        if (!DS_DebugEnabled()) return;

        if (mode != null && mode.GetInt() == 1)
        {
            CVar prog2 = CVar.FindCVar("projectmalice_dimensionalstability_progression");
            double ceiling = (prog2 != null) ? prog2.GetFloat() : 0.0;
            Console.Printf("[DS] Mode: Progression");
            Console.Printf("[DS] Ceiling (this level): %d%%", int(ceiling * 100.0 + 0.5));
        }
        else
        {
            CVar stat = CVar.FindCVar("projectmalice_dimensionalstability");
            double sp = (stat != null) ? stat.GetFloat() : 0.0;
            Console.Printf("[DS] Mode: Static");
            Console.Printf("[DS] Static proportion: %d%%", int(sp * 100.0 + 0.5));
        }
    }

    // Keep drone cleanup at the end of the level (no summary here anymore).
    override void WorldUnloaded(WorldEvent e)
    {
        if (deathmatch || e.IsReopen) return;

        // Store summary for next map's WorldLoaded to print
        prevMapName  = level.MapName;
        prevEligible = dsEligible;
        prevReplaced = dsReplaced;

        // Stop drone on level transition
        if (ghostSounder)
        {
            ghostSounder.StopDrone();
            ghostSounder.Destroy();
            ghostSounder = null;
        }
        ghostCurrentVolume = 0.0;
    }

    override void WorldTick()
    {
        if (level.total_monsters > 0 && level.killed_monsters >= level.total_monsters)
        {
            if (ghostSounder)
            {
                ghostSounder.StopDrone();
                ghostSounder.Destroy();
                ghostSounder = null;
                ghostCurrentVolume = 0.0;
                if (DroneDebug()) Console.Printf("[DS:Drone] 100%% kills -> stopping loop.");
            }
            return;
        }

        double p = DS_GetActiveP();
        DS_UpdateDrone(p);
    }

    override void CheckReplacement(ReplaceEvent e)
    {
        Name cls = e.Replacee.GetClassName();

        if (!DS_IsEligible(cls)) return;
        dsEligible++;

        double p = DS_GetActiveP();
        if (p <= 0.0) return;
        if (frandom(0.0, 1.0) > p) return;

        switch (cls)
        {
            case 'DoomImp':       e.Replacement = "PM_GhostImp";           break;
            case 'Demon':         e.Replacement = "PM_GhostDemon";         break;
            case 'Spectre':       e.Replacement = "PM_GhostSpectre";       break;
            case 'LostSoul':      e.Replacement = "PM_GhostLostSoul";      break;
            case 'Cacodemon':     e.Replacement = "PM_GhostCacodemon";     break;
            case 'Hellknight':
            case 'HellKnight':    e.Replacement = "PM_GhostHellKnight";    break;
            case 'BaronOfHell':   e.Replacement = "PM_GhostBaron";         break;
            case 'Revenant':      e.Replacement = "PM_GhostRevenant";      break;
            case 'Arachnotron':   e.Replacement = "PM_GhostArachnotron";   break;
            case 'Fatso':         e.Replacement = "PM_GhostMancubus";      break;
            case 'PainElemental': e.Replacement = "PM_GhostPainElemental"; break;
            case 'Archvile':      e.Replacement = "PM_GhostArchvile";      break;
        }

        dsReplaced++;
    }
}