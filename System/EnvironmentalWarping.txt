// ===============================
// Backups
// ===============================
class PM_SectorOrig : Object
{
	Sector    sec;
	TextureID floorTex;
	TextureID ceilTex;
	int       lightLevel;
	// Tint/fog are restored to neutral defaults (white light, black fade, density 0).
}

class PM_SideOrig : Object
{
	Side      side;
	bool      hadTop, hadMid, hadBot;
	TextureID topTex, midTex, botTex;
}

// ===============================
// Looped ambient drone for ground-zero sectors
// ===============================
class PM_OtherSideDrone : Actor
{
	Sound  Picked; // one of PM/OtherSideDrone1..5
	double Vol;    // 0.0 .. 1.0 constant per instance

	Default
	{
		+NOBLOCKMAP +NOGRAVITY +NOINTERACTION +NOBLOOD +DONTGIB
		RenderStyle "Normal";
		Alpha 0; // avoid float truncation warning
		Radius 2;
		Height 2;
	}

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();

		int r = Random(1, 5);
		if (r == 1)      Picked = "PM/OtherSideDrone1";
		else if (r == 2) Picked = "PM/OtherSideDrone2";
		else if (r == 3) Picked = "PM/OtherSideDrone3";
		else if (r == 4) Picked = "PM/OtherSideDrone4";
		else             Picked = "PM/OtherSideDrone5";

		Vol = frandom(0.0, 1.0);

		// Loop the positional sound on this actor
		A_StartSound(Picked, CHAN_BODY, CHANF_LOOP, Vol, ATTN_NORM);
	}

	States
	{
	Spawn:
		TNT1 A 35;
		Loop;
	}
}

// ===============================
// Infection controller (pool-enabled, with cleanse)
// ===============================
class PM_SectorBleedInfection : EventHandler
{
	bool didScan;
	bool didRevert;
	int  waitTics;

	// Pools hold resolved TextureIDs.
	Array<TextureID> floorPool;
	Array<TextureID> ceilPool;
	Array<TextureID> wallPool;

	Array<PM_SectorOrig> sectorBackups;
	Array<PM_SideOrig>   sideBackups;

	// track spawned drones for cleanup
	Array<Actor> drones;

	// -------- CLEANSE FX state (for center-message rendering) --------
	int    cleanseMsgTics;     // countdown in tics (~35 tics/sec)
	String cleanseMsg;         // text to draw centered

	int _clampi(int v, int lo, int hi) { return v < lo ? lo : (v > hi ? hi : v); }

	// ---------------- IGNORE HELPERS ----------------

	bool IsDamaging(Sector s)
	{
		return s != null && s.damageamount > 0;
	}

	bool IsSkyCeiling(Sector s)
	{
		if (s == null) return false;

		int pidx = s.Portals[Sector.Ceiling]; // 0 => none
		if (pidx != 0)
		{
			SectorPortal sp = level.SectorPortals[pidx];
			if (sp != null)
			{
				if (sp.mType == SectorPortal.TYPE_SKYVIEWPOINT
				 || sp.mType == SectorPortal.TYPE_PLANE
				 || sp.mType == SectorPortal.TYPE_HORIZON
				 || (sp.mFlags & SectorPortal.FLAG_SKYFLATONLY) != 0
				 || sp.mSkybox != null)
				{
					return true;
				}
			}
		}

		TextureID cur = s.GetTexture(Sector.Ceiling);
		if (cur.IsValid())
		{
			Name nm = TexMan.GetName(cur);
			if (nm == 'F_SKY1' || nm == 'F_SKY2') return true;
		}

		return false;
	}

	bool IsInteractiveLine(Line ln)
	{
		if (ln == null) return false;
		if (ln.special != 0) return true;
		if (ln.locknumber > 0) return true;
		if ((ln.flags & Line.ML_REPEAT_SPECIAL) != 0) return true;
		return false;
	}

	bool IsTwoSidedMidTextureLine(Line ln)
	{
		if (ln == null) return false;
		if ((ln.flags & Line.ML_TWOSIDED) == 0) return false;

		Side fs = ln.sidedef[0];
		Side bs = ln.sidedef[1];

		bool fmid = (fs != null) && !fs.GetTexture(Side.mid).IsNull();
		bool bmid = (bs != null) && !bs.GetTexture(Side.mid).IsNull();

		return fmid || bmid;
	}

	bool IsRailingFlagged(Line ln)
	{
		if (ln == null) return false;
		return (ln.flags & (Line.ML_RAILING | Line.ML_3DMIDTEX)) != 0;
	}

	// ---------------- TINT / FOG HELPERS ----------------

	void SetSectorTint(Sector s, int r, int g, int b)
	{
		r = _clampi(r,0,255); g = _clampi(g,0,255); b = _clampi(b,0,255);
		s.SetColor(Color(r,g,b), 0);
	}

	void SetSectorFog(Sector s, int r, int g, int b, int density)
	{
		r = _clampi(r,0,255); g = _clampi(g,0,255); b = _clampi(b,0,255);
		if (density < 0) density = 0;
		s.SetFade(Color(r,g,b));
		s.SetFogDensity(density);
	}

	void ApplyTintPreset(Sector s, string strength)
	{
		if (strength == "light")        { SetSectorTint(s, 195, 85, 35); }
		else if (strength == "medium")  { SetSectorTint(s, 205, 165, 145); }
		else                            { SetSectorTint(s, 200, 95, 45); }
	}

	void ApplyFogPreset(Sector s, string which)
	{
		int RUST_FOG_R = 30, RUST_FOG_G = 10, RUST_FOG_B = 0;

		if (which == "r0_black_veryheavy") { SetSectorFog(s, 4, 2, 1, 150); }
		else if (which == "r1_rust_heavy") { SetSectorFog(s, RUST_FOG_R, RUST_FOG_G, RUST_FOG_B, 50); }
		else                                { SetSectorFog(s, RUST_FOG_R, RUST_FOG_G, RUST_FOG_B, 10); }
	}

	void ClearTintFog(Sector s)
	{
		s.SetColor(Color(255,255,255), 0);
		s.SetFade(Color(0,0,0));
		s.SetFogDensity(0);
	}

	// -------------------------------------------------------------------

	override void WorldLoaded(WorldEvent e)
	{
		if (gameState == GS_TITLELEVEL || deathmatch || e.IsReopen) return;

		didScan   = false;
		didRevert = false;

		if (pm_infect_scandelay < 1) waitTics = 1;
		else waitTics = pm_infect_scandelay;

		sectorBackups.Clear();
		sideBackups.Clear();
		drones.Clear();

		// reset cleanse message state
		cleanseMsgTics = 0;
		cleanseMsg     = "";

		BuildPools();

		if (pm_infect_debug)
			Console.Printf("PM_Infect: pools -> floors=%d, ceilings=%d, walls=%d.",
				floorPool.Size(), ceilPool.Size(), wallPool.Size());
	}

	override void WorldTick()
	{
		if (!pm_infect_enable) return;

		// tick down the center message timer if active
		if (cleanseMsgTics > 0) cleanseMsgTics--;

		if (!didScan)
		{
			waitTics--;
			if (waitTics <= 0)
			{
				ApplyBleed();
				didScan = true;
			}
		}
		else if (!didRevert)
		{
			if (level.total_monsters > 0 && level.killed_monsters >= level.total_monsters)
			{
				RestoreAll();
				didRevert = true;
				if (pm_infect_debug) Console.Printf("PM_Infect: Cleansed (100%% kills).");
			}
		}
	}

	// Draw the 3-second center message for all players when active
	override void RenderOverlay(RenderEvent e)
{
    if (cleanseMsgTics <= 0 || cleanseMsg.Length() == 0) return;

    Font f = "SmallFont";

    // Virtual canvas (no 'const' in ZScript functions)
    int vw = 320, vh = 200;

    // Scale down to one-third
    double sx = 1.0 / 3.0;
    double sy = 1.0 / 3.0;

    int baseW = f.StringWidth(cleanseMsg);
    int baseH = f.GetHeight();

    // Center using the *scaled* dimensions
    int x = int((vw - baseW * sx) / 2.0);
    int y = int((vh - baseH * sy) / 2.0);

    Screen.DrawText(
        f, Font.CR_WHITE, x, y, cleanseMsg,
        DTA_VirtualWidth,  vw,
        DTA_VirtualHeight, vh,
        DTA_KeepRatio,     true,
        DTA_ScaleX,        sx,
        DTA_ScaleY,        sy
    );
}



	// ===============================
	// Pools
	// ===============================
	void BuildPools()
	{
		floorPool.Clear();
		ceilPool.Clear();
		wallPool.Clear();

		TextureID id;

		// Floors
		id = ResolveTex(pm_infect_floor1); if (id.IsValid()) floorPool.Push(id);
		id = ResolveTex(pm_infect_floor2); if (id.IsValid()) floorPool.Push(id);
		id = ResolveTex(pm_infect_floor3); if (id.IsValid()) floorPool.Push(id);
		id = ResolveTex(pm_infect_floor4); if (id.IsValid()) floorPool.Push(id);
		id = ResolveTex(pm_infect_floor5); if (id.IsValid()) floorPool.Push(id);
		id = ResolveTex(pm_infect_floor6); if (id.IsValid()) floorPool.Push(id);
		id = ResolveTex(pm_infect_floor7); if (id.IsValid()) floorPool.Push(id);
		id = ResolveTex(pm_infect_floor8); if (id.IsValid()) floorPool.Push(id);

		// Ceilings
		id = ResolveTex(pm_infect_ceiling1); if (id.IsValid()) ceilPool.Push(id);
		id = ResolveTex(pm_infect_ceiling2); if (id.IsValid()) ceilPool.Push(id);
		id = ResolveTex(pm_infect_ceiling3); if (id.IsValid()) ceilPool.Push(id);
		id = ResolveTex(pm_infect_ceiling4); if (id.IsValid()) ceilPool.Push(id);
		id = ResolveTex(pm_infect_ceiling5); if (id.IsValid()) ceilPool.Push(id);
		id = ResolveTex(pm_infect_ceiling6); if (id.IsValid()) ceilPool.Push(id);
		id = ResolveTex(pm_infect_ceiling7); if (id.IsValid()) ceilPool.Push(id);
		id = ResolveTex(pm_infect_ceiling8); if (id.IsValid()) ceilPool.Push(id);

		// Walls
		id = ResolveTex(pm_infect_wall1); if (id.IsValid()) wallPool.Push(id);
		id = ResolveTex(pm_infect_wall2); if (id.IsValid()) wallPool.Push(id);
		id = ResolveTex(pm_infect_wall3); if (id.IsValid()) wallPool.Push(id);
		id = ResolveTex(pm_infect_wall4); if (id.IsValid()) wallPool.Push(id);
		id = ResolveTex(pm_infect_wall5); if (id.IsValid()) wallPool.Push(id);
		id = ResolveTex(pm_infect_wall6); if (id.IsValid()) wallPool.Push(id);
		id = ResolveTex(pm_infect_wall7); if (id.IsValid()) wallPool.Push(id);
		id = ResolveTex(pm_infect_wall8); if (id.IsValid()) wallPool.Push(id);

		if (pm_infect_debug) Console.Printf("PM_Infect: pools ok.");
	}

	TextureID ResolveTex(string name)
	{
		if (name.Length() == 0) { TextureID t; t.SetInvalid(); return t; }
		TextureID id = TexMan.CheckForTexture(name, TexMan.Type_Any);
		if (!id.IsValid() && pm_infect_debug) Console.Printf("PM_Infect: missing texture '%s'", name);
		return id;
	}

	TextureID Pick(Array<TextureID> pool)
	{
		if (pool.Size() == 0) { TextureID t; t.SetInvalid(); return t; }
		int i = Random(0, pool.Size() - 1);
		return pool[i];
	}

	// ===============================
	// Core
	// ===============================
	void ApplyBleed()
	{
		int secCount = level.sectors.Size();
		if (secCount <= 0) return;

		Array<bool> r0, r1, r2, tmp;
		r0.Resize(secCount); r1.Resize(secCount); r2.Resize(secCount); tmp.Resize(secCount);
		for (int i = 0; i < secCount; i++) { r0[i]=r1[i]=r2[i]=tmp[i]=false; }

		// Ring construction (adjacency)
		MarkGroundZero(r0);
		BuildNeighborRing(r0, r1);
		BuildNeighborRing(r1, tmp);
		for (int i = 0; i < secCount; i++) r2[i] = (tmp[i] && !r0[i] && !r1[i]);

		// --- Proximity promotion using live PMGhost actor positions ---
		ProximityPromoteFromGhosts(r0, r1, r2, 400.0, 600.0);

		// Apply
		int c0=0, c1=0, c2=0;
		for (int s = 0; s < secCount; s++) if (r0[s]) { ApplyRing0(level.sectors[s]); c0++; }
		for (int s = 0; s < secCount; s++) if (r1[s] && !r0[s]) { ApplyRing1(level.sectors[s]); c1++; }
		for (int s = 0; s < secCount; s++) if (r2[s] && !r0[s] && !r1[s]) { ApplyRing2(level.sectors[s]); c2++; }

		if (pm_infect_debug) Console.Printf("PM_Infect Bleed: R0=%d, R1=%d, R2=%d.", c0, c1, c2);
	}

	void RestoreAll()
	{
		// Only perform cleanse FX if we actually infected/restored anything this map
		bool hadWarp = (drones.Size() > 0) || (sideBackups.Size() > 0) || (sectorBackups.Size() > 0);

		// CLEANSE FX: blackout + center text + global sound (per player), before visual restore
		if (hadWarp)
		{
			// 6 seconds @ 35 tics/sec
			cleanseMsg     = "The air feels lighter...";
			cleanseMsgTics = 210;

			for (int i = 0; i < MAXPLAYERS; i++)
			{
				PlayerInfo p = players[i];
				if (p && p.mo && (p.mo is "PlayerPawn"))
				{
					let pp = PlayerPawn(p.mo);

					// Brief full black so players don't see the instant revert
					pp.A_SetBlend("000000", 1.0, 140);

					// Cleansed stinger (non-positional so everyone hears it equally)
					pp.A_StartSound("PM/WarpingCleansed", CHAN_AUTO, CHANF_DEFAULT, 1.0, ATTN_NONE);
				}
			}
		}

		// stop and remove all drones
		for (int i = 0; i < drones.Size(); i++)
		{
			if (drones[i] != null) drones[i].Destroy();
		}
		drones.Clear();

		// Kill all PMGhosts on cleanse (ensure none remain)
		{
			ThinkerIterator itg = ThinkerIterator.Create("Actor");
			Actor ga;
			while ((ga = Actor(itg.Next())))
			{
				if (ga.bIsMonster && ga.Species == 'PMGhost')
				{
					ga.Destroy();
				}
			}
		}

		// Walls first
		for (int i = 0; i < sideBackups.Size(); i++)
		{
			PM_SideOrig b = sideBackups[i];
			if (b.side == null) continue;

			if (b.hadTop) b.side.SetTexture(Side.top,    b.topTex);
			if (b.hadMid) b.side.SetTexture(Side.mid,    b.midTex);
			if (b.hadBot) b.side.SetTexture(Side.bottom, b.botTex);
		}

		// Then sectors
		for (int i = 0; i < sectorBackups.Size(); i++)
		{
			PM_SectorOrig b = sectorBackups[i];
			if (b.sec == null) continue;

			b.sec.SetTexture(Sector.Floor,   b.floorTex);
			b.sec.SetTexture(Sector.Ceiling, b.ceilTex);

			b.sec.lightlevel = _clampi(b.lightLevel, pm_min_lightlevel, pm_max_lightlevel);

			// Neutralize tint/fog to defaults (white light, black fog, density 0)
			ClearTintFog(b.sec);
		}
	}

	// ===============================
	// Ring detection
	// ===============================
	void MarkGroundZero(Array<bool> r0)
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor a;
		while ((a = Actor(it.Next())))
		{
			if (!a.bIsMonster) continue;
			if (a.Species != 'PMGhost') continue;

			Sector s = a.CurSector;
			if (s == null) s = level.PointInSector(a.Pos.xy);
			if (s == null) continue;

			r0[s.Index()] = true;

			if (pm_infect_debug)
				Console.Printf("PM_Infect: Ground zero at sec %d (%.0f, %.0f)", s.Index(), a.Pos.X, a.Pos.Y);
		}
	}

	void BuildNeighborRing(Array<bool> fromRing, Array<bool> outRing)
	{
		int secCount = level.sectors.Size();
		for (int i = 0; i < secCount; i++)
		{
			if (!fromRing[i]) continue;
			Sector s = level.sectors[i];

			for (int li = 0; li < s.lines.Size(); li++)
			{
				Line ln = s.lines[li];

				Side fs = ln.sidedef[0];
				Side bs = ln.sidedef[1];

				if (fs != null && fs.sector == s && bs != null && bs.sector != null) outRing[bs.sector.Index()] = true;
				else if (bs != null && bs.sector == s && fs != null && fs.sector != null) outRing[fs.sector.Index()] = true;
			}
		}
	}

	// Distance-based “fill” using PMGhost actor positions
	void ProximityPromoteFromGhosts(Array<bool> r0, Array<bool> r1, Array<bool> r2, double r1dist, double r2dist)
	{
		int secCount = level.sectors.Size();
		if (secCount <= 0) return;

		bool hasGhost = false;
		{
			ThinkerIterator it0 = ThinkerIterator.Create("Actor");
			Actor a0;
			while ((a0 = Actor(it0.Next())))
			{
				if (a0.bIsMonster && a0.Species == 'PMGhost') { hasGhost = true; break; }
			}
		}
		if (!hasGhost) return;

		for (int s = 0; s < secCount; s++)
		{
			if (r0[s] || r1[s] || r2[s]) continue;

			Vector2 c = level.sectors[s].centerspot;
			double best = 1e30;

			ThinkerIterator it2 = ThinkerIterator.Create("Actor");
			Actor g;
			while ((g = Actor(it2.Next())))
			{
				if (!g.bIsMonster || g.Species != 'PMGhost') continue;

				double dx = c.X - g.Pos.X;
				double dy = c.Y - g.Pos.Y;
				double d  = Sqrt(dx*dx + dy*dy);

				if (d < best) best = d;
				if (best <= r1dist) break;
			}

			if (best <= r1dist)      r1[s] = true;
			else if (best <= r2dist) r2[s] = true;
		}
	}

	// ===============================
	// Ring effects (with backup)
	// ===============================
	void ApplyRing0(Sector s)
	{
		BackupSectorOnce(s);

		// Light drop
		ApplyLightingOnly(s, pm_r0_light_drop);

		// Fog/tint (unchanged)
		ApplyFogPreset(s, "r0_black_veryheavy");
		ApplyTintPreset(s, "light");

		// Full flats — skip damaging floors / sky ceilings
		if (!IsDamaging(s))
		{
			TextureID fl = Pick(floorPool);
			if (fl.IsValid()) s.SetTexture(Sector.Floor, fl);
		}

		if (!IsSkyCeiling(s))
		{
			TextureID cl = Pick(ceilPool);
			if (cl.IsValid()) s.SetTexture(Sector.Ceiling, cl);
		}

		// Full walls (switch/interactive-safe + skip two-sided midtextures + skip railing flags)
		TextureID wl = Pick(wallPool);
		if (wl.IsValid())
		{
			for (int i = 0; i < s.lines.Size(); i++)
			{
				Line ln = s.lines[i];
				if (IsInteractiveLine(ln) || IsTwoSidedMidTextureLine(ln) || IsRailingFlagged(ln)) continue;

				Side fs = ln.sidedef[0];
				if (fs != null && fs.sector == s) ForceSideTextures(fs, wl);

				Side bs = ln.sidedef[1];
				if (bs != null && bs.sector == s) ForceSideTextures(bs, wl);
			}
		}

		// Spawn a looped drone at sector center for ground-zero sectors
		Vector2 c = s.centerspot;
		double z = s.floorplane.ZAtPoint(c);
		class<Actor> t = "PM_OtherSideDrone";
		Actor drone = Actor.Spawn(t, (c.X, c.Y, z + 8), ALLOW_REPLACE);
		if (drone != null) drones.Push(drone);
	}

	void ApplyRing1(Sector s)
	{
		BackupSectorOnce(s);

		// Slight drop
		ApplyLightingOnly(s, pm_r1_light_drop);

		// Fog/tint (unchanged)
		ApplyFogPreset(s, "r1_rust_heavy");
		ApplyTintPreset(s, "heavy");

		// Partial flats — skip damaging floors / sky ceilings
		if (!IsDamaging(s) && frandom(0.0,1.0) < pm_infect_ring1_ratio)
		{
			TextureID fl = Pick(floorPool);
			if (fl.IsValid()) s.SetTexture(Sector.Floor, fl);
		}

		if (!IsSkyCeiling(s) && frandom(0.0,1.0) < pm_infect_ring1_ratio)
		{
			TextureID cl = Pick(ceilPool);
			if (cl.IsValid()) s.SetTexture(Sector.Ceiling, cl);
		}

		// Partial walls per slot (switch/interactive-safe + skip two-sided midtextures + skip railing flags)
		for (int i = 0; i < s.lines.Size(); i++)
		{
			Line ln = s.lines[i];
			if (IsInteractiveLine(ln) || IsTwoSidedMidTextureLine(ln) || IsRailingFlagged(ln)) continue;

			Side fs = ln.sidedef[0];
			if (fs != null && fs.sector == s) PartialSideTextures(fs, pm_infect_ring1_ratio);

			Side bs = ln.sidedef[1];
			if (bs != null && bs.sector == s) PartialSideTextures(bs, pm_infect_ring1_ratio);
		}
	}

	void ApplyRing2(Sector s)
	{
		BackupSectorOnce(s);

		// Tiny drop
		ApplyLightingOnly(s, pm_r2_light_drop);

		// Fog/tint (unchanged)
		ApplyFogPreset(s, "r2_rust_mid");
		ApplyTintPreset(s, "medium");
	}

	// ===============================
	// Visual helpers + backups
	// ===============================
	void ApplyLightingOnly(Sector s, int lightDrop)
	{
		int ll = s.lightlevel;
		ll = _clampi(ll - lightDrop, pm_min_lightlevel, pm_max_lightlevel);
		s.lightlevel = ll;
	}

	void ForceSideTextures(Side sd, TextureID forced)
	{
		BackupSideOnce(sd);

		TextureID t;

		t = sd.GetTexture(Side.top);
		if (!t.IsNull()) sd.SetTexture(Side.top, forced);

		t = sd.GetTexture(Side.mid);
		if (!t.IsNull()) sd.SetTexture(Side.mid, forced);

		t = sd.GetTexture(Side.bottom);
		if (!t.IsNull()) sd.SetTexture(Side.bottom, forced);
	}

	void PartialSideTextures(Side sd, double chance)
	{
		BackupSideOnce(sd);

		TextureID t;

		t = sd.GetTexture(Side.top);
		if (!t.IsNull() && frandom(0.0,1.0) < chance)
		{
			TextureID pic = Pick(wallPool);
			if (pic.IsValid()) sd.SetTexture(Side.top, pic);
		}

		t = sd.GetTexture(Side.mid);
		if (!t.IsNull() && frandom(0.0,1.0) < chance)
		{
			TextureID pic2 = Pick(wallPool);
			if (pic2.IsValid()) sd.SetTexture(Side.mid, pic2);
		}

		t = sd.GetTexture(Side.bottom);
		if (!t.IsNull() && frandom(0.0,1.0) < chance)
		{
			TextureID pic3 = Pick(wallPool);
			if (pic3.IsValid()) sd.SetTexture(Side.bottom, pic3);
		}
	}

	void BackupSectorOnce(Sector s)
	{
		for (int i = 0; i < sectorBackups.Size(); i++)
			if (sectorBackups[i].sec == s) return;

		PM_SectorOrig b = new("PM_SectorOrig");
		b.sec        = s;
		b.floorTex   = s.GetTexture(Sector.Floor);
		b.ceilTex    = s.GetTexture(Sector.Ceiling);
		b.lightLevel = s.lightlevel;
		sectorBackups.Push(b);
	}

	void BackupSideOnce(Side sd)
	{
		for (int i = 0; i < sideBackups.Size(); i++)
			if (sideBackups[i].side == sd) return;

		PM_SideOrig b = new("PM_SideOrig");
		b.side = sd;

		TextureID t;

		t = sd.GetTexture(Side.top);
		b.hadTop = !t.IsNull(); b.topTex = t;

		t = sd.GetTexture(Side.mid);
		b.hadMid = !t.IsNull(); b.midTex = t;

		t = sd.GetTexture(Side.bottom);
		b.hadBot = !t.IsNull(); b.botTex = t;

		sideBackups.Push(b);
	}
}