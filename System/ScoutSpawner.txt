// ====================================================================
// Static event handler: owns campaign state + spawner setup
// ====================================================================
class PM_ScoutSpawnerEH : StaticEventHandler
{
    int LevelsCleared;                 // persists across maps/saves
    SectorSpawnerThinker ThinkerRef;   // per-map thinker

    override void NewGame()
    {
        LevelsCleared = 0;
    }

    override void WorldLoaded(WorldEvent e)
    {
        // Create one thinker per map and initialize it with current progression.
        ThinkerRef = SectorSpawnerThinker(new("SectorSpawnerThinker"));
        if (ThinkerRef != null)
        {
            ThinkerRef.Init(LevelsCleared);

            // HUB FILTER (DELAYED): start paused and schedule a delayed evaluation (fixed 1s).
            ThinkerRef.BeginDelayedHubCheck();

            CVar dcv = CVar.GetCVar('pm_scout_debug');
            if (dcv && dcv.GetBool())
            {
                Console.Printf("Scout spawner: waiting 1 s to evaluate monster count...");
            }
        }
    }

    override void WorldUnloaded(WorldEvent e)
    {
        // Count any map exit as completed.
        LevelsCleared++;
    }
}


// ====================================================================
// Thinker: spawns one scout per interval; interval scales with clears
// ====================================================================
class SectorSpawnerThinker : Thinker
{
    // ---- Spawn pool ----
    Array<Name> ScoutActors;              
    Array<int>  SpawnWeights;

    // ---- Timing state ----
    int IntervalCounter;
    int SpawnIntervalSeconds;
    int SpawnIntervalTics;
    int ResyncCounter;
    int FailCooldownTics;
    int GraceTics;

    // --- Cached progression for this map ---
    int LevelsClearedForThisMap;

    // --- HUB FILTER state ---
    bool PausedForHub;            // true if this map is hub/empty or while checking
    bool HubCheckPending;         // true while waiting before evaluating total_monsters
    int  HubCheckDelayTics;       // countdown in tics before evaluating

    void Init(int levelsCleared)
    {
        LevelsClearedForThisMap = levelsCleared;

        // Spawn pool
        ScoutActors.Clear(); SpawnWeights.Clear();
        ScoutActors.Push('PM_ScoutCharred');
        ScoutActors.Push('PM_FallenScout');
        SpawnWeights.Push(50);
        SpawnWeights.Push(50);

        RecomputeIntervalFromCvars();

        int gsec = 20;
        CVar gcv = CVar.GetCVar('pm_scout_grace_seconds');
        if (gcv) gsec = gcv.GetInt();
        if (gsec < 0) gsec = 0;
        GraceTics = gsec * TICRATE;

        IntervalCounter  = 0;
        ResyncCounter    = 0;
        FailCooldownTics = 0;

        // Start paused until we finish the delayed hub check.
        PausedForHub     = true;
        HubCheckPending  = false;
        HubCheckDelayTics= 0;
    }

    // ---------------- HUB FILTER (delayed check) ----------------
    void BeginDelayedHubCheck()
    {
        // Fixed 1-second delay; no CVAR involved.
        HubCheckDelayTics = TICRATE;
        HubCheckPending   = true;
        PausedForHub      = true; // remain paused until we evaluate
    }

    void FinalizeHubCheck()
    {
        bool shouldPause = (level != null) && (level.total_monsters <= 3);
        PausedForHub = shouldPause;
        HubCheckPending = false;

        CVar dcv = CVar.GetCVar('pm_scout_debug');
        if (dcv && dcv.GetBool())
        {
            if (shouldPause)
                Console.Printf("Scout spawner: paused (hub/empty map detected: total_monsters=%d)", level ? level.total_monsters : -1);
            else
                Console.Printf("Scout spawner: active (combat map detected: total_monsters=%d)", level ? level.total_monsters : -1);
        }
    }
    // ------------------------------------------------------------

    void RecomputeIntervalFromCvars()
    {
        int baseSec = 120, stepSec = 3, minSec = 30;

        CVar cv;
        cv = CVar.GetCVar('pm_scout_interval_base'); if (cv) baseSec = cv.GetInt();
        cv = CVar.GetCVar('pm_scout_interval_step'); if (cv) stepSec = cv.GetInt();
        cv = CVar.GetCVar('pm_scout_interval_min');  if (cv) minSec  = cv.GetInt();

        int s = baseSec - (stepSec * LevelsClearedForThisMap);
        if (s < minSec) s = minSec;

        SpawnIntervalSeconds = s;
        SpawnIntervalTics    = SpawnIntervalSeconds * TICRATE;
    }

    override void Tick()
    {
        // Master toggle
        CVar on = CVar.GetCVar('pm_scout_enabled');
        if (on && !on.GetBool()) return;
        if (SpawnIntervalTics <= 0) return;

        // Handle delayed hub check (stay paused while waiting)
        if (HubCheckPending)
        {
            if (HubCheckDelayTics > 0)
            {
                HubCheckDelayTics--;
                Super.Tick();
                return;
            }
            FinalizeHubCheck();
            // fall through; if we just unpaused, we can continue ticking normally
        }

        // Pause gate (hub/empty maps)
        if (PausedForHub)
        {
            Super.Tick();
            return;
        }

        // Keep timing in sync with CVAR tweaks (once per second)
        ResyncCounter++;
        if (ResyncCounter >= TICRATE)
        {
            ResyncCounter = 0;
            RecomputeIntervalFromCvars();
        }

        // Initial grace period
        if (GraceTics > 0)
        {
            GraceTics--;
            Super.Tick();
            return;
        }

        // Post-failure cooldown
        if (FailCooldownTics > 0)
        {
            FailCooldownTics--;
            Super.Tick();
            return;
        }

        IntervalCounter++;

        if (IntervalCounter >= SpawnIntervalTics)
        {
            bool spawned = TrySpawnOneRandomActor();
            if (spawned)
            {
                IntervalCounter = 0;
            }
            else
            {
                int coolSec = 0;
                CVar cv = CVar.GetCVar('pm_scout_fail_cooldown');
                if (cv) coolSec = cv.GetInt();
                if (coolSec < 0) coolSec = 0;
                FailCooldownTics = coolSec * TICRATE;
            }
        }

        Super.Tick();
    }

    // ------------------- Walkability pre-checks -------------------
    bool PrecheckSpot(Sector sec, Vector2 p2, out double outFloorZ)
    {
        int clearance = 56, flatStep = 24, flatRadius = 16;
        CVar cv;
        cv = CVar.GetCVar('pm_scout_clearance');       if (cv) clearance = cv.GetInt();
        cv = CVar.GetCVar('pm_scout_flatness_step');   if (cv) flatStep  = cv.GetInt();
        cv = CVar.GetCVar('pm_scout_flatness_radius'); if (cv) flatRadius= cv.GetInt();

        double floorZ  = sec.floorplane.ZAtPoint(p2);
        double ceilZ   = sec.ceilingplane.ZAtPoint(p2);
        if (ceilZ - floorZ < clearance) return false;

        Vector2 dirs[8];
        dirs[0].x=-1; dirs[0].y= 0; dirs[1].x= 1; dirs[1].y= 0;
        dirs[2].x= 0; dirs[2].y=-1; dirs[3].x= 0; dirs[3].y= 1;
        dirs[4].x=-1; dirs[4].y=-1; dirs[5].x= 1; dirs[5].y=-1;
        dirs[6].x=-1; dirs[6].y= 1; dirs[7].x= 1; dirs[7].y= 1;

        for (int i = 0; i < 8; i++)
        {
            Vector2 pn;
            pn.x = p2.x + dirs[i].x * flatRadius;
            pn.y = p2.y + dirs[i].y * flatRadius;

            Vector3 probe;
            probe.x = pn.x; probe.y = pn.y; probe.z = floorZ;
            if (!level.IsPointInLevel(probe)) return false;

            double nf = sec.floorplane.ZAtPoint(pn);
            if (abs(nf - floorZ) > flatStep) return false;
        }

        outFloorZ = floorZ;
        return true;
    }

    // ------------------- Spawn attempt -------------------
    bool TrySpawnOneRandomActor()
    {
        if (ScoutActors.Size() == 0 || level == null || level.sectors.Size() == 0)
            return false;

        int idx = GetRandomActorIndex();
        Name typeName = ScoutActors[idx];

        class<Actor> cls = typeName;
        if (cls == null)
        {
            CVar dcv = CVar.GetCVar('pm_scout_debug');
            if (dcv && dcv.GetBool())
                Console.Printf("Scout spawner: unknown class '%s'", typeName);
            return false;
        }

        int SectorTries = 128, JitterTries = 8;
        int JitterMax   = 128;

        CVar cv;
        cv = CVar.GetCVar('pm_scout_attempt_sectors'); if (cv) SectorTries = cv.GetInt();
        cv = CVar.GetCVar('pm_scout_attempt_jitter');  if (cv) JitterTries = cv.GetInt();

        if (SectorTries < 8)   SectorTries = 8;
        if (SectorTries > 256) SectorTries = 256;
        if (JitterTries < 1)   JitterTries = 1;
        if (JitterTries > 16)  JitterTries = 16;

        for (int i = 0; i < SectorTries; i++)
        {
            int sidx = Random(0, level.sectors.Size() - 1);
            Sector sec = level.sectors[sidx];

            Vector2 c = sec.centerspot;

            for (int j = 0; j < JitterTries; j++)
            {
                double ox = c.x + Random(-JitterMax, JitterMax);
                double oy = c.y + Random(-JitterMax, JitterMax);
                Vector2 p2; p2.x = ox; p2.y = oy;

                double floorZ;
                if (!PrecheckSpot(sec, p2, floorZ)) continue;

                Vector3 pos;
                pos.x = p2.x; pos.y = p2.y; pos.z = floorZ;

                if (!level.IsPointInLevel(pos)) continue;

                let mo = Actor.Spawn(cls, pos);
                if (mo && mo.TestMobjLocation())
                {
                    CVar dcv2 = CVar.GetCVar('pm_scout_debug');
                    if (dcv2 && dcv2.GetBool())
                        Console.Printf("A scout is investigating...");
                    return true;
                }
                else if (mo)
                {
                    mo.Destroy();
                }
            }
        }
        return false;
    }

    int GetRandomActorIndex()
    {
        int total = 0;
        for (int i = 0; i < SpawnWeights.Size(); i++)
            total += SpawnWeights[i];
        if (total <= 0) return 0;

        int roll = Random(0, total - 1);
        for (int i = 0; i < SpawnWeights.Size(); i++)
        {
            roll -= SpawnWeights[i];
            if (roll < 0) return i;
        }
        return 0;
    }
}