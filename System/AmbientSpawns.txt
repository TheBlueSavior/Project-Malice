// a simple data class used to contain a position
// arrays don't support vectors for some reason
class DropperPoint {
    vector3 pos;
}

class PM_FodderDropper : EventHandler {
    bool doSpawn;
    int spawnDelay;

    // Roll is now an instance variable (accessible via EventHandler.Find)
    double roll;

    override void WorldLoaded(WorldEvent e) {
        if (gameState == GS_TITLELEVEL || deathmatch || e.IsReopen)
            return;

        doSpawn = true;
        spawnDelay = 1;

        // progression mode: increment progression cvar at new level start
        if (CVar.GetCVar("projectmalice_foddermode").GetInt() == 1) {
            CVar prog = CVar.FindCVar("projectmalice_fodderprogression");
            CVar inc  = CVar.FindCVar("projectmalice_fodderincrement");

            double newVal = prog.GetFloat() + inc.GetFloat();
            if (newVal > 20.0) newVal = 20.0; // ceiling
            prog.SetFloat(newVal);

            if (CVar.GetCVar("projectmalice_fodder_debug").GetBool()) {
                Console.Printf("[PM:Fodder] %s: Progression increased by %.2f â†’ %.2f (capped at 20.0)",
                    level.MapName, inc.GetFloat(), prog.GetFloat());
            }
        }
    }

    override void NewGame() {
        // reset progression on new game
        CVar.FindCVar("projectmalice_fodderprogression").SetFloat(0.0);

        if (CVar.GetCVar("projectmalice_fodder_debug").GetBool()) {
            Console.Printf("[PM:Fodder] New game started, progression reset to 0.0");
        }
    }

    override void WorldTick() {
        if (!doSpawn) {
            if (!bDESTROYED)
                Destroy();
            return;
        }
        if (spawnDelay-- > 0)
            return;

        doSpawn = false;
        array<DropperPoint> dropperPoints;

        actor mobj;
        let it = ThinkerIterator.Create();        
        while (mobj = Actor(it.Next())) {
            if (mobj is "PlayerPawn" || !mobj.bISMONSTER) continue;
            if (mobj.bFLOAT) continue;

            let newPoint = New("DropperPoint");
            newPoint.pos = mobj.pos;
            dropperPoints.Push(newPoint);
        }
        if (dropperPoints.Size() <= 0) return;

        int mode = CVar.FindCVar("projectmalice_foddermode").GetInt();
        double extraMonsters;

        if (mode == 0) {
            // static divider
            CVar foddersetting = CVar.FindCVar("projectmalice_fodderdivider");
            roll = frandom(0, foddersetting.GetFloat());
            extraMonsters = level.total_monsters * roll;
        } else {
            // progression scaling (already capped in WorldLoaded)
            CVar prog = CVar.FindCVar("projectmalice_fodderprogression");
            roll = frandom(0, prog.GetFloat());
            extraMonsters = level.total_monsters * roll;
        }

        // Debug info
        if (CVar.GetCVar("projectmalice_fodder_debug").GetBool()) {
            Console.Printf("[PM:Fodder] %s: Mode=%d Progression=%.2f Roll=%.2f Extra=%i",
                level.MapName, mode,
                CVar.FindCVar("projectmalice_fodderprogression").GetFloat(),
                roll, extraMonsters);
        }

        // spawn the monsters
        for (int i = 0; i < extraMonsters; i++) {
            let dropPoint = dropperPoints[random(0, dropperPoints.Size() - 1)];
            let act = Actor.Spawn("PM_HorrorPassiveSpawn", dropPoint.pos);
            act.angle = random(0, 8) * 45;
        }
    }
}
